# 소프트웨어 공학

> 소프트웨어는 상품. 공학은 좋은 상품을 낮은 가격에 계획대로 만들기 위한 방법론.

<br>

<br>

## 소프트웨어란?

* 단순 프로그램이 아닌 개발, 운용, 보수에 필요한 모든 관련 정보(설계문서가 가장 큰 비중)
* 설계, 개발과정에서 비용이 많이들고 완제품 생산은 비교적 저비용
* 소프트웨어엔 물리적인 부품이 없기 때문에 `신뢰도`의 결정은 생산과정이 아닌 설계과정에서 측정
* 결함을 설계과정의 `테스팅`으로 찾아내는 형식.(물리적 검출 불가)

<br>

<br>

## **소프트웨어의 특징**

* **복잡성 (complexity)** - 수 많은 내부요소들이 있어 상호작용이 많고 복잡하다.
  * 문제가 무엇인지, 요구가 무엇인지 잘 정의하기 힘들다.
  * 요구되는 사항이 서로 상충되어 설계가 어렵다.

* **순응성 (conformity)** - 요구나 환경, 데이터에 따라서 적절하게 변형된다.

* **변경성 (changeability)** - 문자로 구성된 프로그램이라 쉽게 변경할 수 있고, 개발 과정에서 자주 변경된다.
  * 하지만 오류가 늦게 발견될수록 수정비용은 크다.
  * 설계에서 오는 오류가 개발작업에서 오는 오류보다 크다.

* **비가시성 (invisibility)** - 구조가 코드 안에 숨어 있어 쉽게 드러나지 않음.

<br>

## 소프트웨어 개발의 잘못된 통념

* 개발은 주로 프로그래밍 작업이다 -> 대부분 설계와 요구분석 작업
* 소프트웨어는 고치기 쉽다 -> 고치기 매우매우 어려움
* 최신 첨단 기술이문제를 해결해줄 것이다 -> 구조적 문제는 기술의 발전이 해결하기 힘듦
* 소프트웨어의 개발은 프로그램의 완성까지다 -> 유지보수까지가 소프트웨어 개발이다.
* 개발자는 프로그램의 기능이 명세에 대하여 맞는지만 보인다 -> 다른 클래스와 인터페이스도 맞춰줘야한다.

<br>

> 소프트웨어는 물리적 구조가 없어 마모되지 않는데 점점 품질이 낮아지는 이유는?
>
> 많은 변경으로 인해 컴포넌트의 상호작용에 오류가 생긴다.
>
> SW는 잦은 변경이 control되기 매우 힘들고 구조화하기 어렵기 때문에 점점 영향받는 범위가 커지고 그게 손쓸 수 없게 되버리는 경우가 많다(기술부채로 인한 파산.)

<br>

## **소프트웨어 공학의 목적**

1. **복잡도 낮춤** - 프로젝트의 복잡도를 줄이기 위함
2. **비용 최소화** - 필요하지 않는 일이나 중복되는 일을 최소화 하기 위함
3. **개발 기간 단축** - 계획을 세우고 관리하여 기간을 단축하기 위함.
4. **대규모 프로젝트 관리** - 큰 프로젝트를 관리하기 위함.
5. **고품질 소프트웨어** - 신뢰성(잘 작동된다는)을 보장하기 위하여 시험과 유지보수 실행.
6. **효율성** - 표준화를 하여 작업의 효율을 높이기 위함.

즉, 소프트웨어 공학은 **품질 좋은 소프트웨어**를 **최소의 비용**으로 **계획된 일정에 맞추어 개발**하는 것이다. ( 고품질, 납기, 저비용, 고효율)

<br>

## 소프트웨어 공학에서 배울 것은 무엇일까?

1. 방법 : 소프트웨어 개발에 사용되는 기법 ex.) 객체지향분석
2. 도구 : 자동화된 시스템을 말하는데 설계, 프로그래밍 테스트 도구
3. 프로세스 : 도구와 방법을 적용하는 순서. ( 프로세스에 따라 효율이 결정된다.)
4. 패러다임 : 방법론을 일컫는다. ( 구조적, 객체지향적 방법론)

<br>

## SWEBOK(Software Engineering Body Of Knowlefge)

* 개발자가 알아야 하는 지식체계
* IEEE 산하 소프트웨어 공학 표준위원회와 ACM이 정한 기준



1. 소프트웨어 요구분석 : 사용자 요구의 추출, 분석, 검증, 관리
2. 소프트웨어 설계 : 사용자가 원하는 요구를 만족 시킬 수 있는 솔루션 설계
3. 소프트웨어 구축 : 설계대로 프로그램을 작성하는 코딩, 이를 확인하는 검증 및 단위 테스트 작업
4. 스프트웨어 테스팅 : 테스팅에 관한 기본 개념, 수준, 측정, 과정, 도구
5. 소프트웨어 유지보수 : 유지보수 개념과 작업 및 관리, 비용, 측정
6. 소프트웨어 형상관리 : 시스템을 이루고 있는 구성요소들을 잘 파악하고 이들의 변경 릴리스 관리
7. 소프트웨어 엔지니어링 프로세스 : 소프트웨어 프로젝트의 계획, 실행, 평가, 조정의 관리
8. 소프트웨어 엔지니어링 프로세스 : 소프트웨어 프로세스의 정의, 구현, 측정, 관리, 변경, 개선
9. 소프트웨어 엔지니어링 도구와 방법 : 소프트웨어 개발 방법 및 도구와 컴포넌트 통합에 관한 지식
10. 소프트웨어 품질 : 프로덕트 품질의 개념과 품질 특성, 품질 보증을 위한 계획, 활동에 관한 지식
11. 기타 : 컴퓨터 공학, 컴퓨터 과학, 경영학, 수학, 프로젝트 관리, 품질관리, 소프트웨어 인간공학, 시스템공학.



> 상호작용하는 서브시스템 구성하기 위해 기능분할.
>
> 시스템의 경계를 찾기 위해 외부 환경과의 입출력을 찾음
>
> 서브시스템 사이의 관계를 명확히 규정
>
> 소프트웨어 이외의 기계, 문서, 작업절차, 교육 등 요소도 고려.

<br>

## 좋은 소프트웨어가 가지는 특질(품질 결정 요소)

> 소프트웨어는 비용, 일정, 품질이 중요하고
>
> 품질은 삼각균형이라 불리는 기술, 인력, 프로세스가 결정한다.

* Usability : 유용성
  * 사용하기 용이(쉽게 이해, 배울수 있는) 
  * 만족하지 못하면 고품질, 고성능 프로그램도 쓸수없다.(이해가 안되므로)
  * 누가봐도 어떤 구조인지 알아야한
* Efficiency : 효율성
  * CPU와 Memory의 자원을 효율적으로 사용해야함
  * 만족하지 못하면 최소사양이 높아지고 사용자 불편을 가져온다
* **Reliablity : 신뢰성**
  * 소프트웨어가 정해진 수준의 성능을 유지할 수 있는 능력.(트래픽 부하를 어디까지 유지?)
* functionalioty : 기능성
  * 원래 정한, 내재된 요구한 기능을 만족하면서 작동해야함
* Maintanablity :유지성
  * 위와 같이 구조를 쉽게 알 수 있어서 개발자가 아닌 사람도 유지보수가 가능하게 만들어야함
* Reusability : 재사용성
  * 소프트웨어가 다른 소프트웨어에도 쓰일 수 있도록 범용성을 가져야함.

* portability : 이식성
  * 별도의 작동이나 수단 없이 다양한 환경에서 적응될 수 있는 능력
  * 어떠한 운영체제 내에서만 작동한다면 접근성이 떨어진다.

<br>

## 소프트웨어 공학 분류

1. **단계적 프로세스**
2. **품질 보증**
3. **프로젝트 관리**

<br>

---

<br>

### **1. 단계적 프로세스**

\>> 소프트웨어 개발을 코딩에 치중하지 않고 **요구분석, 설계, 코딩, 테스팅 등의 정해진 절차를 따라 작업**하는 것이다.

장점 - 개발을 하는 동안 **정해진 시점에 품질과 생산성을 효율적으로 점검**할 수 있다.

| 단계     | 초점                                  | 주요작업과 기술                                              | 결과물                   |
| -------- | ------------------------------------- | ------------------------------------------------------------ | ------------------------ |
| 요구분석 | - 시스템을 위하여 무엇을 만들 것인가? | - 분석 전략 수립 - 요구 결정 - 유스케이스 분석 - 구조적 모델링 - 동적 모델링 | 요구분석 명세서          |
| 설계     | - 시스템을 어떻게 구축할 것인가?      | - 설계 전략 수립 - 아키텍쳐 설계 - 인터페이스 설계 - 프로그램 설계 - 데이터베이스, 파일 설계 | 설계 명세서              |
| 구현     | - 시스템의 코딩과 단위 시험           | - 프로그래밍 - 단위 테스팅 - 시스템 안정화 및 유지보수       | 새 시스템, 유지보수 계획 |
| 테스팅   | - 시스템이 요구에 맞게 실행되나?      | - 통합 테스팅 - 시스템 테스팅 - 인수 테스팅 - 시스템의 설치 - 프로젝트 관리 계획 | 테스팅 결과 보고서       |

 <br>

---

<br>

### **2. 품질 보증**

\>> **소프트웨어가 요구와 품질 수준을 만족시키는지 검토하고 확인, 테스팅**

| 작업               | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| 검토(Verification) | 각 단계의 작업이 제시된 절차와 방법에 맞게 진행되었는지 체크하는 작업 |
| 확인(Validation)   | 개발 완료된 결과물이 품질 수준에 맞게 생산되었는지 검사하는 작업 |
| 테스팅             | 구현된 소프트웨어를 실행하여 예상된 결과를 보이는지 확인하는 작업 |

 <br>

**바람직한 소프트웨어가 가져야 할 특징**

| 특징       | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| 유지보수성 | 변화하는 고객의 요구에 맞게 소프트웨어가 발전하는 특징       |
| 신뢰성     | 보안과 안전을 포함한 다양한 성질, 시스템이 장애를 일으켰을 때 물리적, 경제적 손실을 발생시키지 않는 특징 |
| 효율성     | 메모리, 프로세스 머신 사이클과 같은 시스템 자원을 낭비하지 않는 성질 |
| 유용성     | 사용자가 큰 노력을 들이지 않고 쉽게 사용할 수 있는 특성 (적절한 사용자 인터페이스와 문서를 제공하여 만족할 수 있음) |

 <br>

---

<br>

### **3. 프로젝트 관리**

\>> **프로젝트의 제약 조건들을 확인하고 적절히 관리하는 작업**

#### **프로젝트 관리 활동**

| 관리 활동                | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 프로젝트 계획            | 소프트웨어 개발이 시작되기 전, 범위 결정 및 타당성 검토를 통하여 소프트웨어 개발의 방향성과 일정, 방법 등을 계획하는 것 |
| 자원 관리                | 소프트웨어를 개발하는 데 사용될 자원을 적절하게 산정하고 할당 및 관리하는 것 |
| 리스크 관리              | 위험요소를 예측하고 이를 식별, 분석하여 대비책을 세우는 관리 활동 |
| 프로젝트 수행과 모니터링 | 프로젝트의 모든 작업이 계획에 맞게 진행되고 있는지 확인하는 작업. |

